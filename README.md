# goit-algo-hw-10

## Порівняння алгоритмів

### Жадібний алгоритм
- **Ідея**: завжди брати найбільший доступний номінал.  
- **Складність**: O(k), де k — кількість монет.  
- **Переваги**: дуже швидкий, простий.
- **Недоліки**: не завжди оптимальний (залежить від набору монет).

### Алгоритм динамічного програмування
- **Ідея**: обчислює мінімальну кількість монет для кожної суми від 1 до N.  
- **Складність**: O(k·n), де n — сума, k — кількість номіналів.  
- **Переваги**: завжди знаходить оптимальний результат.  
- **Недоліки**: повільний для великих сум.

---

Тести показали такі резултати

```
Сума: 113
Greedy: {50: 2, 10: 1, 2: 1, 1: 1} | час: 0.000003 c
DP: {50: 2, 10: 1, 2: 1, 1: 1} | час: 0.000044 c

Сума: 3456
Greedy: {50: 69, 5: 1, 1: 1} | час: 0.000002 c
DP: {50: 69, 5: 1, 1: 1} | час: 0.001302 c

Сума: 65738
Greedy: {50: 1314, 25: 1, 10: 1, 2: 1, 1: 1} | час: 0.000001 c
DP: {50: 1314, 25: 1, 10: 1, 2: 1, 1: 1} | час: 0.027532 c

Сума: 987654
Greedy: {50: 19753, 2: 2} | час: 0.000002 c
DP: {50: 19753, 2: 2} | час: 0.428914 c

```

## Висновки

- Для класичного набору монет ([50, 25, 10, 5, 2, 1]) жадібний алгоритм завжди оптимальний і значно швидший.  
- Для довільних наборів монет жадібний алгоритм може давати не мінімальну кількість монет, тому потрібно використовувати динамічне програмування.
